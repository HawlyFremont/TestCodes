C51 COMPILER V8.06   0                                                                     09/16/2013 18:36:22 PAGE 1   


C51 COMPILER V8.06, COMPILATION OF MODULE 0
OBJECT MODULE PLACED IN 0.OBJ
COMPILER INVOKED BY: C:\Keil\C51\BIN\C51.EXE 0.c BROWSE DEBUG OBJECTEXTEND

line level    source

   1          /**********************BST-V51实验开发板例程************************
   2          
   3          *  平台：BST-V51 + Keil U3 + STC89C52
   4          *  名称：读取18B20序列码并用1602显示
   5          *  公司：深圳市亚博软件开发有限公司
   6          *  淘宝：bstmcu.taobao.com       
   7          *  日期：2012-8-14
   8          *  晶振:11.0592MHZ
   9          *  说明：免费开源，不提供源代码分析.
  10          
  11          ******************************************************************/
  12          
  13          /*读取DS18B20的64位序列码并显示在1602液晶上，如果读取正确结果，则在
  14          液晶第一行显示DS18B20 OK，第二行显示序列码，如果读取失败，则在液晶上
  15          显示DS18B20  ERR0R PLEASE CHECK ，用户可通过更改18B20接口自己外接。 */
  16          #include <reg51.h>
  17          #include <intrins.h>
  18          
  19          #define uchar unsigned char
  20          #define uint  unsigned int
  21          
  22          sbit DQ = P2^2;  //定义DS18B20端口DQ  
  23          sbit BEEP=P2^3 ; //蜂鸣器驱动线
  24          
  25          bit  presence ;
  26          
  27          sbit LCD_RS = P1^0;             
  28          sbit LCD_RW = P1^1;
  29          sbit LCD_EN = P2^5;
  30          
  31          uchar code  cdis1[ ] = {"   DS18B20 OK   "};
  32          uchar code  cdis2[ ] = {"                "};
  33          uchar code  cdis3[ ] = {" DS18B20  ERR0R "};
  34          uchar code  cdis4[ ] = {"  PLEASE CHECK  "};
  35          
  36          unsigned char data  display[2] = {0x00,0x00};
  37                                              
  38          unsigned char data  RomCode[8] = {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};
  39          
  40          unsigned char Temp;
  41          unsigned char  crc;
  42          
  43          void beep();
  44          
  45          #define delayNOP(); {_nop_();_nop_();_nop_();_nop_();};
  46          
  47          /*******************************************************************/
  48          void delay1(int ms)
  49          {
  50   1       unsigned char y;
  51   1        while(ms--)
  52   1       {
  53   2        for(y = 0; y<250; y++)
  54   2        {
  55   3         _nop_();
C51 COMPILER V8.06   0                                                                     09/16/2013 18:36:22 PAGE 2   

  56   3         _nop_();
  57   3         _nop_();
  58   3         _nop_();
  59   3        }
  60   2       }
  61   1      }
  62          
  63          /******************************************************************/
  64          /*                                                                */
  65          /*检查LCD忙状态                                                   */
  66          /*lcd_busy为1时，忙，等待。lcd-busy为0时,闲，可写指令与数据。     */
  67          /*                                                                */
  68          /******************************************************************/ 
  69          
  70          bit lcd_busy()
  71           {                          
  72   1          bit result;
  73   1          LCD_RS = 0;
  74   1      //    LCD_RW = 1;
  75   1          LCD_EN = 1;
  76   1          delayNOP();
  77   1          result = (bit)(P0&0x80);
  78   1          LCD_EN = 0;
  79   1          return(result); 
  80   1       }
  81          
  82          /*******************************************************************/
  83          /*                                                                 */
  84          /*写指令数据到LCD                                                  */
  85          /*RS=L，RW=L，E=高脉冲，D0-D7=指令码。                             */
  86          /*                                                                 */
  87          /*******************************************************************/
  88          
  89          void lcd_wcmd(uchar cmd)
  90          
  91          {                          
  92   1       //  while(lcd_busy());
  93   1          LCD_RS = 0;
  94   1       //   LCD_RW = 0;
  95   1          LCD_EN = 0;
  96   1          _nop_();
  97   1          _nop_(); 
  98   1          P0 = cmd;
  99   1          delayNOP();
 100   1          LCD_EN = 1;
 101   1          delayNOP();
 102   1          LCD_EN = 0;  
 103   1              delay1(5);
 104   1      }
 105          
 106          /*******************************************************************/
 107          /*                                                                 */
 108          /*写显示数据到LCD                                                  */
 109          /*RS=H，RW=L，E=高脉冲，D0-D7=数据。                               */
 110          /*                                                                 */
 111          /*******************************************************************/
 112          
 113          void lcd_wdat(uchar dat)
 114          {                          
 115   1      //   while(lcd_busy());
 116   1          LCD_RS = 1;
 117   1      //    LCD_RW = 0;
C51 COMPILER V8.06   0                                                                     09/16/2013 18:36:22 PAGE 3   

 118   1          LCD_EN = 0;
 119   1          P0 = dat;
 120   1          delayNOP();
 121   1          LCD_EN = 1;
 122   1          delayNOP();
 123   1          LCD_EN = 0; 
 124   1              delay1(5);
 125   1      }
 126          
 127          /*******************************************************************/
 128          /*                                                                 */
 129          /*  LCD初始化设定                                                  */
 130          /*                                                                 */
 131          /*******************************************************************/
 132          
 133          void lcd_init()
 134          { 
 135   1           LCD_RW = 0;
 136   1          delay1(15);   
 137   1          lcd_wcmd(0x01);      //清除LCD的显示内容
 138   1                  
 139   1          lcd_wcmd(0x38);      //16*2显示，5*7点阵，8位数据
 140   1          delay1(5);
 141   1          lcd_wcmd(0x38);         
 142   1          delay1(5);
 143   1          lcd_wcmd(0x38);         
 144   1          delay1(5);
 145   1      
 146   1          lcd_wcmd(0x0c);      //显示开，关光标
 147   1          delay1(5);
 148   1          lcd_wcmd(0x06);      //移动光标
 149   1          delay1(5);
 150   1          lcd_wcmd(0x01);      //清除LCD的显示内容
 151   1          delay1(5);
 152   1      }
 153          
 154          /*******************************************************************/
 155          /*                                                                 */
 156          /*  设定显示位置                                                   */
 157          /*                                                                 */
 158          /*******************************************************************/
 159          
 160          void lcd_pos(uchar pos)
 161          {                          
 162   1        lcd_wcmd(pos | 0x80);  //数据指针=80+地址变量
 163   1      }
 164          
 165          /*******************************************************************/
 166          /*                                                                 */
 167          /*us级延时函数                                                     */
 168          /*                                                                 */
 169          /*******************************************************************/
 170          
 171          void Delay(unsigned int num)
 172          {
 173   1        while( --num );
 174   1      }
 175          
 176          /*******************************************************************/
 177          /*                                                                 */
 178          /*初始化ds1820                                                     */
 179          /*                                                                 */
C51 COMPILER V8.06   0                                                                     09/16/2013 18:36:22 PAGE 4   

 180          /*******************************************************************/
 181          Init_DS18B20(void)
 182          {  
 183   1           DQ = 1;      //DQ复位
 184   1           Delay(8);    //稍做延时
 185   1      
 186   1           DQ = 0;      //将DQ拉低
 187   1           Delay(90);   //精确延时 大于 480us
 188   1      
 189   1           DQ = 1;       //拉高总线
 190   1           Delay(8);
 191   1      
 192   1           presence = DQ;    //读取存在信号
 193   1           Delay(100);
 194   1           DQ = 1; 
 195   1           
 196   1           return(presence); //返回信号，0=presence,1= no presence
 197   1      }
 198          
 199          /*******************************************************************/
 200          /*                                                                 */
 201          /* 读一位（bit）                                                   */
 202          /*                                                                 */
 203          /*******************************************************************/
 204          uchar read_bit(void) 
 205          {
 206   1      unsigned char i;
 207   1      DQ = 0;                  //将DQ 拉低开始读时间隙
 208   1      DQ = 1;                         // then return high
 209   1      for (i=0; i<3; i++);    // 延时15μs
 210   1      return(DQ);                     // 返回 DQ 线上的电平值
 211   1      }
 212          
 213          /*******************************************************************/
 214          /*                                                                 */
 215          /* 读一个字节                                                      */
 216          /*                                                                 */
 217          /*******************************************************************/
 218           ReadOneChar(void)
 219          {
 220   1      unsigned char i = 0;
 221   1      unsigned char dat = 0;
 222   1      
 223   1      //for (i = 8; i > 0; i--)
 224   1      //  {
 225   1      //       read_bit();
 226   1      //    DQ = 0; // 给脉冲信号
 227   1      //     dat >>= 1;
 228   1      //    DQ = 1; // 给脉冲信号
 229   1      for (i=0;i<8;i++) 
 230   1      {                               // 读取字节，每次读取一个字节
 231   2      if(read_bit()) dat|=0x01<<i;    // 然后将其左移
 232   2      
 233   2      //    if(DQ)
 234   2      //     dat |= 0x80;
 235   2          Delay(4);
 236   2        }
 237   1      
 238   1          return (dat);
 239   1      }
 240          
 241          /*******************************************************************/
C51 COMPILER V8.06   0                                                                     09/16/2013 18:36:22 PAGE 5   

 242          /*                                                                 */
 243          /* 写一位                                                          */
 244          /*                                                                 */
 245          /*******************************************************************/
 246          void write_bit(char bitval) {
 247   1      DQ = 0;                                        // 将DQ 拉低开始写时间隙
 248   1      if(bitval==1) DQ =1;     // 如果写1，DQ 返回高电平
 249   1      Delay(5);                                     // 在时间隙内保持电平值，
 250   1      DQ = 1;                  // Delay函数每次循环延时16μs，因此delay(5) = 104μs
 251   1      }       
 252          
 253          /*******************************************************************/
 254          /*                                                                 */
 255          /* 写一个字节                                                      */
 256          /*                                                                 */
 257          /*******************************************************************/
 258           WriteOneChar(unsigned char dat)
 259          {
 260   1        unsigned char i = 0;
 261   1        unsigned char temp;
 262   1      //  for (i = 8; i > 0; i--)
 263   1      //  {
 264   1         for (i=0; i<8; i++)  // 写入字节, 每次写入一位 
 265   1         {
 266   2      //    DQ = 0;
 267   2      //    DQ = dat&0x01;
 268   2      //    Delay(5);
 269   2      
 270   2      //    DQ = 1;
 271   2         temp = dat>>i;               
 272   2         temp &= 0x01;                
 273   2         write_bit(temp);
 274   2      //    dat>>=1;
 275   2         
 276   2        }
 277   1        Delay(5);
 278   1      }
 279          
 280          /*******************************************************************/
 281          /*                                                                 */
 282          /* 读取64位序列码                                                  */
 283          /*                                                                 */
 284          /*******************************************************************/
 285           Read_RomCord(void)
 286          {
 287   1           unsigned char j;
 288   1           Init_DS18B20();
 289   1        
 290   1           WriteOneChar(0x33);  // 读序列码的操作
 291   1           for (j = 0; j < 8; j++)
 292   1               {
 293   2                RomCode[j] = ReadOneChar() ; 
 294   2               }
 295   1      }
 296          
 297          /*******************************************************************/
 298          /*                                                                 */
 299          /*DS18B20的CRC8校验程序                                            */
 300          /*                                                                 */
 301          /*******************************************************************/
 302          uchar CRC8() 
 303          { 
C51 COMPILER V8.06   0                                                                     09/16/2013 18:36:22 PAGE 6   

 304   1         uchar i,x; uchar crcbuff;
 305   1         
 306   1         crc=0;
 307   1         for(x = 0; x <8; x++)
 308   1         {
 309   2          crcbuff=RomCode[x];
 310   2          for(i = 0; i < 8; i++) 
 311   2           { 
 312   3            if(((crc ^ crcbuff)&0x01)==0) 
 313   3            crc >>= 1; 
 314   3             else { 
 315   4                    crc ^= 0x18;   //CRC=X8+X5+X4+1
 316   4                    crc >>= 1; 
 317   4                    crc |= 0x80; 
 318   4                  }         
 319   3            crcbuff >>= 1;       
 320   3               }
 321   2         }
 322   1           return crc;        
 323   1      }
 324          /*******************************************************************/
 325          /*                                                                 */
 326          /* 数据转换与显示                                                  */
 327          /*                                                                 */
 328          /*******************************************************************/
 329          
 330           Disp_RomCode()
 331          {
 332   1         uchar j;
 333   1         uchar H_num=0x40;       //LCD第二行初始位置
 334   1      
 335   1         for(j=0;j<8;j++)
 336   1         {
 337   2          Temp = RomCode[j];
 338   2      
 339   2          display[0]=((Temp&0xf0)>>4);
 340   2          if(display[0]>9)
 341   2           { display[0]=display[0]+0x37;}
 342   2          else{display[0]=display[0]+0x30;}
 343   2      
 344   2          lcd_pos(H_num);             
 345   2          lcd_wdat(display[0]);        //高位数显示 
 346   2      
 347   2          H_num++;
 348   2          display[1]=(Temp&0x0f);
 349   2          if(display[1]>9)
 350   2           {display[1]=display[1]+0x37;}
 351   2          else {display[1]=display[1]+0x30;}
 352   2      
 353   2          lcd_pos(H_num);             
 354   2          lcd_wdat(display[1]);        //低位数显示 
 355   2          H_num++;
 356   2         }
 357   1      }        
 358          
 359          /*******************************************************************/
 360          /*                                                                 */
 361          /* 蜂鸣器响一声                                                    */
 362          /*                                                                 */
 363          /*******************************************************************/
 364          void beep()
 365            {
C51 COMPILER V8.06   0                                                                     09/16/2013 18:36:22 PAGE 7   

 366   1          unsigned char y;
 367   1          for (y=0;y<100;y++)
 368   1          {
 369   2            Delay(60);
 370   2            BEEP=!BEEP;                //BEEP取反
 371   2          } 
 372   1          BEEP=1;                      //关闭蜂鸣器
 373   1              Delay(40000);
 374   1        }
 375          
 376          /*******************************************************************/
 377          /*                                                                 */
 378          /* DS18B20 OK 显示菜单                                             */
 379          /*                                                                 */
 380          /*******************************************************************/
 381          void  Ok_Menu ()
 382          { 
 383   1          uchar  m;
 384   1          lcd_init();                //初始化LCD 
 385   1                  
 386   1          lcd_pos(0);                //设置显示位置为第一行的第1个字符
 387   1           m = 0;
 388   1          while(cdis1[m] != '\0')
 389   1           {                         //显示字符
 390   2             lcd_wdat(cdis1[m]);
 391   2             m++;
 392   2           }
 393   1      
 394   1          lcd_pos(0x40);             //设置显示位置为第二行第1个字符
 395   1           m = 0;
 396   1          while(cdis2[m] != '\0')
 397   1           {
 398   2             lcd_wdat(cdis2[m]);      //显示字符
 399   2             m++;
 400   2           }
 401   1      }
 402          
 403          /*******************************************************************/
 404          /*                                                                 */
 405          /* DS18B20 ERROR 显示菜单                                          */
 406          /*                                                                 */
 407          /*******************************************************************/
 408          void  Error_Menu ()
 409          {
 410   1           uchar  m;
 411   1           lcd_init();                //初始化LCD 
 412   1              
 413   1               lcd_pos(0);                //设置显示位置为第一行的第1个字符
 414   1           m = 0;
 415   1           while(cdis3[m] != '\0')
 416   1           {                         //显示字符
 417   2             lcd_wdat(cdis3[m]);
 418   2             m++;
 419   2           }
 420   1      
 421   1           lcd_pos(0x40);             //设置显示位置为第二行第1个字符
 422   1           m = 0;
 423   1           while(cdis4[m] != '\0')
 424   1           {
 425   2             lcd_wdat(cdis4[m]);      //显示字符
 426   2             m++;
 427   2           }
C51 COMPILER V8.06   0                                                                     09/16/2013 18:36:22 PAGE 8   

 428   1      }
 429          
 430          /*******************************************************************/
 431          /*                                                                 */
 432          /* 主函数                                                          */
 433          /*                                                                 */
 434          /*******************************************************************/
 435          void main()
 436           {
 437   1           P0 = 0xff;
 438   1           P2 = 0xff;
 439   1      
 440   1         while(1)
 441   1        {
 442   2           Ok_Menu ();
 443   2           Read_RomCord();    //读取64位序列码
 444   2           CRC8();            //CRC效验
 445   2           if(crc==0)         //CRC效验正确
 446   2               {
 447   3                Disp_RomCode();       //显示64位序列码
 448   3                beep();
 449   3           }
 450   2           while(!presence)
 451   2               {
 452   3                Init_DS18B20();
 453   3                delay1(1000);
 454   3               }
 455   2      
 456   2           Error_Menu ();
 457   2              do
 458   2               {  
 459   3                 Init_DS18B20();
 460   3                 beep();
 461   3           }
 462   2              while(presence);
 463   2        }
 464   1      }
 465          
 466          /*******************************************************************/


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    641    ----
   CONSTANT SIZE    =     68    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     12    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      1       1
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
